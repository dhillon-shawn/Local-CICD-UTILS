name: Compute Version
description: Simulate version resolution without external calls
branding:
  icon: "package"
  color: "purple"
inputs:
  pid:              {  required: true, description: "" }
  bump_major:              {  required: true, description: "" }

outputs:
  version:
    value: ${{ steps.set.outputs.NEW_VERSION }}
    description: ""

runs:
  using: composite
  steps:

    - name: Get latest version
      id: get_latest_version
      shell: bash
      run: |
        RESPONSE=$(
          curl --location \
            --header "Authorization: Bearer ${{ env.TOKEN }}" \
            "${{ env.OR_URL }}/odata/Processes/UiPath.Server.Configuration.OData.GetProcessVersions(processId='${{inputs.pid}}')?%24orderby=Version%20desc&%24top=1&%24select=Version"
        )
        LATEST_VERSION=$(echo "$RESPONSE" | jq -r '.value[0].Version')
        if [[ -z "$LATEST_VERSION" || "$LATEST_VERSION" == "null" ]]; then
          LATEST_VERSION="0.0.0"
        fi
        echo "LATEST_VERSION=$LATEST_VERSION" >> "$GITHUB_ENV"

          
    - name: Compute auto-bumped version
      id: set
      uses: actions/github-script@v7
      env:
        INPUT_VERSION: ${{ env.LATEST_VERSION }} # or wire a composite input if you have one
        BUMP_MAJOR: ${{ inputs.bump_major }}     # boolean-like string: 'true'/'false'
      with:
        script: |
          const input = process.env.INPUT_VERSION ?? '';
          const bumpMajor = String(process.env.BUMP_MAJOR).toLowerCase() === 'true';

          console.log(`Latest Version: ${input}`);
          console.log(`bumpMajor: ${bumpMajor}`);

          const m = input.match(/[0-9]+(?:\.[0-9]+)*(?:[+-][A-Za-z0-9.-]+)?/);
          if (!m) throw new Error('Could not parse a version from INPUT_VERSION');

          const coreVer = m[0];
          // Drop pre/suffixes
          const base = coreVer.split(/[+-]/, 1)[0];

          const parts = base.split('.').filter(Boolean);
          const N = parts.length;

          const major = Number(parts[0] ?? 0);
          if (!Number.isFinite(major)) throw new Error('Invalid major version');

          let newVersion;

          if (bumpMajor) {
            newVersion = `${major + 1}.0.0`;
          } else {
            const patchRaw = N >= 2 ? Number(parts[N - 1] ?? 0) : 0;
            if (!Number.isFinite(patchRaw)) throw new Error('Invalid patch version');

            let minor = 0;
            if (N > 2) {
              for (let i = 1; i < N - 1; i++) {
                const v = Number(parts[i] ?? 0);
                if (!Number.isFinite(v)) throw new Error(`Invalid minor component at index ${i}`);
                minor += v;
              }
            }

            const inc = patchRaw + 1;
            const newPatch = inc % 10;
            const newMinor = minor + Math.floor(inc / 10);

            newVersion = `${major}.${newMinor}.${newPatch}`;
          }

          core.setOutput('NEW_VERSION', newVersion);
          console.log(`Version: ${newVersion}`);





name: "migrate-assets"
description: "POST/PATCH UiPath assets from assets.values.json; outputs migrated_ok and migrated_fail CSVs"
inputs:
  folder_name:
    description: "X-UIPATH-FolderPath value"
    required: true
  asset_names:
    description: "CSV of all asset names from parse step"
    required: true
runs:
  using: "composite"
  steps:


  - name: Migrate assets (POST/PATCH from list)
    shell: bash
    run: |
      set -euo pipefail
      test -f assets.json

      ok=()
      fail=()

      total=$(jq 'length' assets.json)
      echo "Migrating ${total} assets..."

      for ((i=0; i<total; i++)); do
        body=$(jq -c ".[$i]" assets.json)
        name=$(jq -r '.Name' <<<"$body")

        id=$(
          curl -sS -L \
            -H "Authorization: Bearer ${{ env.TOKEN}}" \
            -H "X-UIPATH-FolderPath: ${{ inputs.folder_name }}" \
            --get --data-urlencode "\$filter=Name eq '$name'" \
            "${OR_URL}/odata/Assets" \
          | jq -r '.value[0].Id // empty'
        )
        echo " asset id: $id"

        if [[ -n "$id" ]]; then
          response="$(mktemp)"
          trap 'rm -f "$response"' EXIT
          status=$(
            curl -L -sS \
              --connect-timeout 10 --max-time 120 \
              --output "$response" \
              --write-out '%{http_code}' \
              -X PATCH \
              -H "Authorization: Bearer ${{ env.TOKEN}}" \
              -H "Content-Type: application/json" \
              -H "X-UIPATH-FolderPath: ${{ inputs.folder_name }}" \
              --data-binary "$body" \
              "${OR_URL}/odata/Assets(${id})"
          )
          echo "Patch response: $status"
          echo "::group::Response body"
          if [[ -s "$response" ]] && command -v jq >/dev/null && jq -e . "$response" >/dev/null 2>&1; then
            jq -r . "$response"
          else
            cat "$response"
          fi
          echo "::endgroup::"
        else
          response="$(mktemp)"
          trap 'rm -f "$response"' EXIT
          status=$(
            curl -L -sS \
              --connect-timeout 10 --max-time 120 \
              --output "$response" \
              --write-out '%{http_code}' \
              -X POST \
              -H "Authorization: Bearer ${{ env.TOKEN }}" \
              -H "Content-Type: application/json" \
              -H "X-UIPATH-FolderPath: ${{ inputs.folder_name }}" \
              --data-binary "$body" \
              "${OR_URL}/odata/Assets"
          )
          echo "Post Response: $status"
          echo "::group::Response body"
          if [[ -s "$response" ]] && command -v jq >/dev/null && jq -e . "$response" >/dev/null 2>&1; then
            jq -r . "$response"
          else
            cat "$response"
          fi
          echo "::endgroup::"
        fi

        echo "[$((i+1))/${total}] ${name} -> ${status}"

        if [[ ${status:-0} -ge 200 && ${status:-0} -lt 400 ]]; then
          ok+=("$name")
        else
          fail+=("$name")
        fi
      done

      declare -A okmap=()
      for n in "${ok[@]:-}"; do okmap["$n"]=1; done

      not_uploaded=()
      IFS=',' read -ra ALL_ARR <<<"${{inputs.asset_names}}"
      for n in "${ALL_ARR[@]}"; do
        # trim spaces
        n="${n#"${n%%[![:space:]]*}"}"; n="${n%"${n##*[![:space:]]}"}"
        [[ -z "$n" ]] && continue
        if [[ -z "${okmap[$n]+x}" ]]; then
          not_uploaded+=("$n")
        fi
      done

      ok_csv=$(IFS=,; echo "${ok[*]-}")
      fail_csv=$(IFS=,; echo "${fail[*]-}")
      not_csv=$(IFS=,; echo "${not_uploaded[*]-}")

      echo "Migrated OK:         $ok_csv"
      echo "Attempted but FAILED: $fail_csv"
      echo "NOT UPLOADED (ALL-OK): $not_csv"

      echo "migrated_ok=$ok_csv"        >> "$GITHUB_OUTPUT"
      echo "migrated_fail=$fail_csv"    >> "$GITHUB_OUTPUT"
      echo "not_uploaded=$not_csv"      >> "$GITHUB_OUTPUT"

name: "migrate-assets"
description: "POST/PATCH UiPath assets from assets.values.json; outputs migrated_ok and migrated_fail CSVs"
inputs:
  folder_name: { description: "X-UIPATH-FolderPath value", required: true }
  values_path: { description: "Path to assets.values.json", required: false, default: "assets.values.json" }
runs:
  using: "composite"
  steps:


    - name: Upsert assets and collect results
      id: run
      shell: bash
      env:
        FOLDER:   ${{ inputs.folder_name }}
        VALUES:   ${{ inputs.values_path }}
      run: |
        set -euo pipefail
        test -f "$VALUES"

        # Return Asset Id if exists, else empty
        find_asset_id() {
          local name="$1"
          curl -sS -L \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "X-UIPATH-FolderPath: ${FOLDER}" \
            --get --data-urlencode "\$filter=Name eq '$name'" \
            "${OR_URL}/odata/Assets" \
          | jq -r '.value[0].Id // empty'
        }

        # Build JSON body with jq based on type and value (value is already JSON-typed)
        build_body() {
          local name="$1" type="$2" value_json="$3"
          case "$type" in
            Text)
              jq -n --arg n "$name" --argjson v "$value_json" \
                '{Name:$n, ValueType:"Text", StringValue: ( ( $v|type=="string")? $v : ($v|tostring) ) }'
              ;;
            Integer)
              jq -n --arg n "$name" --argjson v "$value_json" \
                '{Name:$n, ValueType:"Integer", IntValue:$v}'
              ;;
            Bool)
              jq -n --arg n "$name" --argjson v "$value_json" \
                '{Name:$n, ValueType:"Bool", BoolValue:$v}'
              ;;
            *)
              return 1
              ;;
          esac
        }

        upsert_one() {
          local name="$1" type="$2" value_json="$3"
          local id body tmp status curl_rc=0
          tmp="$(mktemp)"; trap 'rm -f "$tmp"' RETURN

          body="$(build_body "$name" "$type" "$value_json")" || { echo 400; return; }
          id="$(find_asset_id "$name" || true)"

          if [[ -n "$id" ]]; then
            status=$(
              curl -L -sS \
                --connect-timeout 10 --max-time 120 \
                --output "$tmp" \
                --write-out '%{http_code}' \
                -X PATCH \
                -H "Authorization: Bearer ${TOKEN}" \
                -H "Content-Type: application/json" \
                -H "X-UIPATH-FolderPath: ${FOLDER}" \
                --data-binary "$body" \
                "${OR_URL}/odata/Assets(${id})"
            ) || curl_rc=$?
          else
            status=$(
              curl -L -sS \
                --connect-timeout 10 --max-time 120 \
                --output "$tmp" \
                --write-out '%{http_code}' \
                -X POST \
                -H "Authorization: Bearer ${TOKEN}" \
                -H "Content-Type: application/json" \
                -H "X-UIPATH-FolderPath: ${FOLDER}" \
                --data-binary "$body" \
                "${OR_URL}/odata/Assets"
            ) || curl_rc=$?
          fi

          echo "::group::Upsert ${name} (${type}) -> ${status}"
          if command -v jq >/dev/null; then jq -r . "$tmp" || cat "$tmp"; else cat "$tmp"; fi
          echo "::endgroup::"

          if [[ $curl_rc -ne 0 ]]; then echo 503; else echo "${status:-0}"; fi
        }

        # Build two CSV lists as outputs
        ok_list=()
        fail_list=()
        results='[]'

        # Only migrate assets that were successfully read in dev (status_code==200)
        mapfile -t rows < <(jq -c '.[] | select(.status_code==200)' "$VALUES")
        for row in "${rows[@]}"; do
          name=$(jq -r '.asset_name' <<<"$row")
          type=$(jq -r '.asset_type' <<<"$row")
          val_json=$(jq -c '.asset_value' <<<"$row")

          status=$(upsert_one "$name" "$type" "$val_json")
          if [[ "${status:-0}" -ge 200 && "${status:-0}" -lt 400 ]]; then
            ok_list+=("$name")
          else
            fail_list+=("$name")
          fi

          results=$(jq --arg n "$name" --arg t "$type" --argjson v "$val_json" --argjson s "$status" \
            '. + [{"asset_name":$n,"asset_type":$t,"asset_value":$v,"status_code":$s}]' <<<"$results")
        done

        printf '%s\n' "$results" | jq . > assets.migrated.json

        ok_csv=$(IFS=,; echo "${ok_list[*]-}")
        fail_csv=$(IFS=,; echo "${fail_list[*]-}")

        echo "migrated_ok=$ok_csv"   >> "$GITHUB_OUTPUT"
        echo "migrated_fail=$fail_csv" >> "$GITHUB_OUTPUT"
        echo "path=$GITHUB_WORKSPACE/assets.migrated.json" >> "$GITHUB_OUTPUT"

outputs:
  migrated_ok:
   description: "CSV of successfully migrated asset names"
   value: ${{ steps.run.outputs.migrated_ok }}
  migrated_fail:
    description: "CSV of failed asset names"
    value: ${{ steps.run.outputs.migrated_fail }}

  path:
   description: "Path to assets.migrated.json"
   value: ${{ steps.run.outputs.path }}

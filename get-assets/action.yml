name: "get-assets"
description: "Batch GET UiPath asset values (Text/Integer/Bool) and write assets.values.json"
inputs:
  folder_name:    { description: "X-UIPATH-FolderPath value", required: true }
  asset_filter:  { description: "", required: true }
runs:
  using: "composite"
  steps:


    - name: get string asset vals
      shell: bash
      run: |
        set -euo pipefail
        echo "Getting Strings"
        body="$(mktemp)"
        trap 'rm -f "$body"' EXIT

        curl_rc=0
        status=$(
          curl -L -sS -G \
            --connect-timeout 10 --max-time 120 \
            --output "$body" \
            --write-out '%{http_code}' \
            -H "Authorization: Bearer ${{ env.TOKEN }}" \
            -H "Content-Type: application/json" \
            -H "X-UIPATH-FolderPath: ${{ inputs.folder_name }}" \
            --data-urlencode "\$filter=ValueType eq 'Text' and ${{inputs.asset_filter}}" \
            --data-urlencode "\$select=Name,StringValue" \
            "${{ env.OR_URL }}/odata/Assets/UiPath.Server.Configuration.OData.GetFiltered"
        ) || curl_rc=$?

        echo "Status Code: $status"
        cp "$body" strings.json
        echo "::group::Response body"
        if [[ -s "$body" ]] && command -v jq >/dev/null && jq -e . "$body" >/dev/null 2>&1; then
          jq -r . "$body"
        else
          cat "$body"
        fi
        echo "::endgroup::"
        
        if [[ $curl_rc -ne 0 || ${status:-0} -ge 400 ]]; then
          exit 1
        fi

    - name: Get int asset vals
      shell: bash
      run: |
        set -euo pipefail
        echo "Getting ints"
        body="$(mktemp)"
        trap 'rm -f "$body"' EXIT

        curl_rc=0
        status=$(
          curl -L -sS -G \
            --connect-timeout 10 --max-time 120 \
            --output "$body" \
            --write-out '%{http_code}' \
            -H "Authorization: Bearer ${{ env.TOKEN }}" \
            -H "Content-Type: application/json" \
            -H "X-UIPATH-FolderPath: ${{ inputs.folder_name }}" \
            --data-urlencode "\$filter=ValueType eq 'Integer' and ${{inputs.asset_filter}}" \
            --data-urlencode "\$select=Name,IntValue" \
            "${{ env.OR_URL }}/odata/Assets/UiPath.Server.Configuration.OData.GetFiltered"
        ) || curl_rc=$?

        echo "Status Code: $status"
        cp "$body" ints.json
        echo "::group::Response body"
        if [[ -s "$body" ]] && command -v jq >/dev/null && jq -e . "$body" >/dev/null 2>&1; then
          jq -r . "$body"
        else
          cat "$body"
        fi
        echo "::endgroup::"
        
        if [[ $curl_rc -ne 0 || ${status:-0} -ge 400 ]]; then
          exit 1
        fi

    - name: Get bool asset vals
      shell: bash
      run: |
        set -euo pipefail
        echo "Getting bools"
        body="$(mktemp)"
        trap 'rm -f "$body"' EXIT

        curl_rc=0
        status=$(
          curl -L -sS -G \
            --connect-timeout 10 --max-time 120 \
            --output "$body" \
            --write-out '%{http_code}' \
            -H "Authorization: Bearer ${{ env.TOKEN }}" \
            -H "Content-Type: application/json" \
            -H "X-UIPATH-FolderPath: ${{ inputs.folder_name }}" \
            --data-urlencode "\$filter=ValueType eq 'Bool' and ${{inputs.asset_filter}}" \
            --data-urlencode "\$select=Name,BoolValue" \
            "${{ env.OR_URL }}/odata/Assets/UiPath.Server.Configuration.OData.GetFiltered"
        ) || curl_rc=$?

        echo "Status Code: $status"
        cp "$body" bools.json
        echo "::group::Response body"
        if [[ -s "$body" ]] && command -v jq >/dev/null && jq -e . "$body" >/dev/null 2>&1; then
          jq -r . "$body"
        else
          cat "$body"
        fi
        echo "::endgroup::"
        
        if [[ $curl_rc -ne 0 || ${status:-0} -ge 400 ]]; then
          exit 1
        fi
        

    - name: build simple outputs
      id: out
      shell: bash
      run: |
        set -euo pipefail
        test -f strings.json || echo '{"value":[]}' > strings.json
        test -f ints.json    || echo '{"value":[]}' > ints.json
        test -f bools.json   || echo '{"value":[]}' > bools.json

        # one file with three maps
        jq -n \
          --slurpfile t strings.json \
          --slurpfile i ints.json \
          --slurpfile b bools.json '
          {
            text:    ( ($t[0].value // []) | map({key:.Name, value:.StringValue}) | from_entries ),
            integer: ( ($i[0].value // []) | map({key:.Name, value:.IntValue   }) | from_entries ),
            bool:    ( ($b[0].value // []) | map({key:.Name, value:.BoolValue  }) | from_entries )
          }' > assets.values.simple.json

        # also export as compact JSON strings (3 outputs)
        text_json=$(jq -c '.text'    assets.json)
        int_json=$(jq  -c '.integer' assets.json)
        bool_json=$(jq -c '.bool'    assets.json)

        echo "text_json=${text_json}"   >> "$GITHUB_OUTPUT"
        echo "int_json=${int_json}"     >> "$GITHUB_OUTPUT"
        echo "bool_json=${bool_json}"   >> "$GITHUB_OUTPUT"
        echo "file=$GITHUB_WORKSPACE/assets.json" >> "$GITHUB_OUTPUT"
outputs:
  text_json:
    description: "JSON map of Text assets (name->value)"
    value: ${{ steps.out.outputs.text_json }}
  int_json:
    description: "JSON map of Integer assets (name->value)"
    value: ${{ steps.out.outputs.int_json }}
  bool_json:
    description: "JSON map of Bool assets (name->value)"
    value: ${{ steps.out.outputs.bool_json }}
  file:
    description: "Path to combined file"
    value: ${{ steps.out.outputs.file }}
